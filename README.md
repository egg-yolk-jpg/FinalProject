# FinalProject
This project was based around creating a notetaker app using Java. It required the usage of sockets and secure access to database. If I were to refactor the code, I would change the location of the processing of user data. The application is currently set up to perform input validation on server-side rather than client-side. 

---------------------------------------------------------------------------------------------------------------------------------------------------------------

Program Name: Notetaker App
Programmer: Yakimah Wiley

This is a Notetaker application which allows users (who have credentials stored in a central database) to leave each other messages and read those messages. This application takes the users through a process of: account creation, user login, message composition, message consumption.

This application involved events generated by the user


Important Variables: 
1. states: logged in; logging in; creating account; signed out; on menu"
2. logging_in_states: obtaining username; obtaining password; checking database
3. creating_account_states: validating username; setting password; uploading to database
4. message_states: main menu; reading messages; composing message; uploading to database; obtaining user input; selecting recipient
5. informative: get user; get pass; user constraints; pass constraints; message created; db add error
6. err: A linkedhashmap that stores different error messages and their associated keys
7. success: A linkedhashmap that stores different success messages and their associated keys

Functions:
1. StatesReset: Used to reset all important items for the login menu
2. checkInput: Processes all inputs for the main menu, including database calls 
	- Logged in: Opens up the message writing menu to the user
		secondary_state, tertiary_state, recipient_selection
	- Logging in: Simple log in functionality for pre-existing users
		secondary_state
	- Creating Account: Directs user to the username and password creation functions. After the credentials have been added to the database, the user is automatically logged in
		secondary_state
	- Signed out: Simply Displays the menu
	- On Menu: Determines where the user will be directed after selecting a menu option
3. validateInputOnMain: Determines which of the menus within checkInput() the user will be directed to from "On Menu"
4. UserLogin: Provides text details for obtaining pre-existing user credentials
5. UserCreation: Provides text details for obtaining credentials of new users
6. getUser: Used for both sets of users to validate that the provided usernames follow the naming convention
7. getPass: Similar to getUser(), but specifically for passwords
8. getMessage: Returns the relevant messages based on specific  parameters being passed through
9. Menu: Reads out the main menu text to the users
10. ErrorList: Fills the err hashmap with the appropriate values
11. SuccessList: Fills the success hashmap with the appropriate values
12. DB_UserSetup: Adds new user credentials to the database <UserCreation>
13. DB_Comparison: Validates that a provided set of credentials already exists within the database <UserLogin>
14. EncryptPassword: Encrypts the new password credential using MD5
15. GetDTTM: returns a formatted date\time string 
16. getDBConnection: Sets up the database
17. WriteOut: A function dedicated to the BufferedWriter within the server. It also requires specification for when the BufferedWriter should be flushed
18. LoginScreen: The screen all users are pointed to after successful login
	secondary_state, tertiary_state
19. GetAction: Returns the action that will be used by the LoginScreen
20. DB_getRecipients: returns a list of users who exist within the database to be used for selecting which recipient a message will be delivered to
21. SelectRecipient: The function responsible for informing the user of which recipients they are able to select
22. ValidateRecipient: The function responsible for validating that the user selected a valid recipient
23. ValidateMessageLength: The function responsible for validating that message being sent is within 250 characters (in length)
24. DB_DisplayMessages: This function locates all messages that have been written with the signed in user as the recipient. It them displays all the messages on the client.





Implementation Issues:
-------------------------------------------------
1. BufferedReader - Incomplete Reading:
- I struggled with getting the client to receive all text BufferedReader text at a time. At first I was running into an issue where only one line would be read at a time. After I figured out how to get every line to be read from the server, I ran into an issue where I was unable to exit from the BufferReader (making the remainder of the application inaccessible). Eventually I figured out that I could simply pass through an empty string and use it as a flag to determine when it was time to exit the BufferedReader. This worked well.

2. User Input Passed to Server as NULL
- I had forgotten to write two break statements into one of the functions, leading to the code bypassing two important processes and making the user input appear as null

3. Random SQLException thrown
- For some reason I called the check input function in the middle of processing the account creation. This led to a duplicate attempt at adding the user data into the database.

4. Unable to log recipient selection
- I had a loop in the code that perpetually called the login screen during the recipient selection process without ever setting the recipient. This issue was called by not allowing the program time to wait for a response from the user

5. BufferedWriter Incorrectly Implemented
- When I first began working on the process I forgot how to correctly implement BufferedWriter, which ultimately caused bugs in the program that prevented me from being able to completely test the program. After a little research, I realized that problem was that I was calling the flush() method after each BufferedWriter call, instead of only when I needed data to be printed to the client. After fixing this issue, the program worked as intended, allowing me to continue testing other portions of the program.

6. HashMap changing the order of entries
- This program uses a hashmap for error and success messages. However, during testing I realized that I was seeing unexpected outputs even when manually checking the order of the values. To fix this, I changed the hashmap into a linkedhashmap

7. Debugging input validation
- I found conducting input validation to be more difficult in this project because the code is broken up based on user-generated events. The difficulty comes from the fact that it's more difficult to determine where the invalid input is being directed and why the application is responding in the way it is. Eventually I realized that I could use System.out.println() to narrow down on the areas in which the error is occurring. But even then, the process requires a lot of patience.

Tests:
1. yaki1 - password1
2. tfae1 - p4ssw0rd
3. gdog -pizz4fac3
4. hello - cheesybr34d
5. pizza - asdfghjkl1

